#!/usr/bin/env python3
"""
Telemetry UI (Pygame-CE)

Shows:
- Arena image with checkpoints path; highlights current segment.
- Estimated current pose on the arena during movement.
- Live sensors: lidar, IMU (accel/gyro/heading/temp), rotation, staleness.

Assumptions & notes:
- Loads arena.png and checkpoints_cm.csv (generated by measure_arena.py).
- Loads path.csv (turn_deg, distance_cm) to know segment plan.
- Auto phase tracking: uses advanced.get_rotation_degrees() and lidar deltas
  to infer whether the bot is turning or moving and which segment is active.
- Starting position is first checkpoint; initial heading assumed arbitrary,
  first turn is relative to current facing (controller resets gyro).

Controls:
- R: reload path/checkpoints
- A: toggle auto phase tracking on/off (manual index)
- [ / ]: manual current segment index -/+ (when auto off)
- Esc/Q: quit
"""
import os
import csv
import math
import time
import threading
import subprocess
import pygame as pg
from path_planner import (
    build_auto_path,
    load_fruits_for_overlay,
    read_color_csv,
)

from advanced import (
    init_bot_control, cleanup,
    get_rotation_degrees, get_full_imu_data,
    is_lidar_data_fresh, get_current_distance,
    get_latest_encoders
)
from calibration_config import load_pulses_per_degree, load_pulses_per_cm


ARENA_WIDTH_CM = 118.1
ARENA_HEIGHT_CM = 114.3

FRUIT_SIZE_CM = 2.0                             # square side matching Fruit UI

# Encoder-based odometry constants (matching move_control.py)
PPR = 5632  # Pulses per rotation (same as move_control.py)
WHEEL_DIAMETER = 4.4  # cm
WHEEL_CIRCUMFERENCE = math.pi * WHEEL_DIAMETER  # cm per rotation
DEFAULT_PULSES_PER_CM = PPR / WHEEL_CIRCUMFERENCE
PULSES_PER_CM = load_pulses_per_cm(DEFAULT_PULSES_PER_CM)  # pulses per cm of wheel travel
PULSES_PER_DEGREE = load_pulses_per_degree()

# Wheelbase (distance between left and right wheels)
# Derived from relationship: pulses_per_degree = (pulses_per_cm * wheelbase_cm * π) / 360
# wheelbase_cm = (pulses_per_degree * 360) / (pulses_per_cm * π)
WHEELBASE_CM = (PULSES_PER_DEGREE * 360.0) / (PULSES_PER_CM * math.pi)

CALIBRATION_REFRESH_INTERVAL = 2.5  # seconds between config refreshes


class Odometry:
    def __init__(self):
        self.reset()
        
    def reset(self):
        """Reset odometry to origin"""
        self.x_cm = 0.0
        self.y_cm = 0.0
        self.heading_deg = 0.0
        self.prev_left_enc = None
        self.prev_right_enc = None
        self.total_left_pulses = 0
        self.total_right_pulses = 0
        
    def set_position(self, x_cm, y_cm, heading_deg):
        """Set absolute position (useful for initialization)"""
        self.x_cm = x_cm
        self.y_cm = y_cm
        self.heading_deg = heading_deg
        
    def update(self, left_enc, right_enc):
        """Update odometry based on encoder readings"""
        if self.prev_left_enc is None or self.prev_right_enc is None:
            # First reading - just store
            self.prev_left_enc = left_enc
            self.prev_right_enc = right_enc
            return
            
        # Calculate encoder deltas
        delta_left = left_enc - self.prev_left_enc
        delta_right = right_enc - self.prev_right_enc
        
        # Update totals
        self.total_left_pulses += delta_left
        self.total_right_pulses += delta_right
        
        # Convert to distances
        left_dist_cm = delta_left / PULSES_PER_CM
        right_dist_cm = delta_right / PULSES_PER_CM
        
        # Calculate movement using differential drive kinematics
        forward_cm = (left_dist_cm + right_dist_cm) / 2.0
        # For differential drive: delta_heading = arc_length_difference / wheelbase
        # When right wheel travels more, heading increases (counterclockwise)
        delta_heading_deg = math.degrees((right_dist_cm - left_dist_cm) / WHEELBASE_CM)
        
        # Update heading
        self.heading_deg += delta_heading_deg
        self.heading_deg = self.heading_deg % 360.0
        
        # Update position (integrate forward movement in current heading)
        # Convention: 0° = up (toward negative Y), origin at top-left, +Y downward
        heading_rad = math.radians(self.heading_deg)
        self.x_cm += forward_cm * math.sin(heading_rad)  # +X to the right
        self.y_cm -= forward_cm * math.cos(heading_rad)  # -Y upward (toward top)
        
        # Store current readings for next iteration
        self.prev_left_enc = left_enc
        self.prev_right_enc = right_enc
        
    def get_pose(self):
        """Return current pose (x_cm, y_cm, heading_deg)"""
        return self.x_cm, self.y_cm, self.heading_deg
        
    def get_total_distance(self):
        """Return total distance traveled by each wheel"""
        left_dist = self.total_left_pulses / PULSES_PER_CM
        right_dist = self.total_right_pulses / PULSES_PER_CM
        return left_dist, right_dist


def load_image(path: str) -> pg.Surface:
    img = pg.image.load(path)
    return img


def compute_px_cm(img_w, img_h):
    px_per_cm_x = img_w / ARENA_WIDTH_CM
    px_per_cm_y = img_h / ARENA_HEIGHT_CM
    return px_per_cm_x, px_per_cm_y


def fit_scale_and_offset(win_size, img_size):
    ww, wh = win_size
    iw, ih = img_size
    s = min(ww / iw, wh / ih) if iw and ih else 1.0
    ox = (ww - iw * s) / 2
    oy = (wh - ih * s) / 2
    return s, (ox, oy)


def image_to_screen(pt, scale, offset):
    x, y = pt
    ox, oy = offset
    return (ox + x * scale, oy + y * scale)


def cm_to_image_xy(x_cm, y_cm, px_per_cm_x, px_per_cm_y):
    return (x_cm * px_per_cm_x, y_cm * px_per_cm_y)


def heading_from_up_deg(vx_cm, vy_cm):
    if abs(vx_cm) < 1e-9 and abs(vy_cm) < 1e-9:
        return 0.0
    return math.degrees(math.atan2(vx_cm, -vy_cm)) % 360.0


def wrap_to_180(deg):
    d = (deg + 180.0) % 360.0 - 180.0
    if d <= -180.0:
        d += 360.0
    return d


def load_path(script_dir):
    path_csv = os.path.join(script_dir, "path.csv")
    segs = []  # list of (turn_deg, dist_cm)
    if os.path.exists(path_csv):
        with open(path_csv, newline="") as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    turn = float(row.get("turn_deg", "0"))
                    dist = float(row.get("distance_cm", "0"))
                    segs.append((turn, dist))
                except Exception:
                    pass
    return segs


def load_checkpoints(script_dir):
    pts_csv = os.path.join(script_dir, "checkpoints_cm.csv")
    pts = []
    if os.path.exists(pts_csv):
        with open(pts_csv, newline="") as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    x = float(row.get("x_cm", "0"))
                    y = float(row.get("y_cm", "0"))
                    pts.append((x, y))
                except Exception:
                    pass
    return pts


def execute_path_segments(segments, status_callback=None):
    """Execute path segments using the encoder-based move_control system"""
    try:
        if status_callback:
            status_callback("running")
        
        print(f"Starting path execution with {len(segments)} segments...")
        
        # Import and initialize the RobotController from move_control
        import sys
        import os
        sys.path.append(os.path.dirname(__file__))
        
        # Import the RobotController directly
        from move_control import RobotController
        from calibration_config import load_motor_factors
        import advanced
        
        # Load and apply motor factors before creating controller
        left_factor, right_factor = load_motor_factors()
        advanced.set_motor_factors(left_factor, right_factor)
        print(f"Applied motor factors: L={left_factor:.3f}, R={right_factor:.3f}")
        
        # Create controller instance
        print("Creating RobotController...")
        controller = RobotController()
        current_ppd = load_pulses_per_degree()
        controller.PULSES_PER_DEGREE = current_ppd
        controller.session_pulses_per_degree = current_ppd
        current_ppc = load_pulses_per_cm(controller.DEFAULT_PULSES_PER_CM)
        controller.PULSES_PER_CM = current_ppc
        controller.session_pulses_per_cm = current_ppc
        print(f"Calibrated pulses-per-degree: {current_ppd:.2f}")
        print(f"Calibrated pulses-per-cm: {current_ppc:.2f}")
        
        # CRITICAL: Use same motor speeds as calibration utilities (measure_ppd/ppc use 45)
        # Different speeds cause different motor behavior and over/undershoot
        turn_speed = 45  # Must match measure_ppd_encoder_only.py DEFAULT_SPEED
        move_speed = 45  # Must match measure_ppc_encoder_only.py DEFAULT_SPEED
        
        print(f"Using calibration-matched motor settings: turn_speed={turn_speed}, move_speed={move_speed}")
        controller.configure_speeds(turn_speed=turn_speed, move_speed=move_speed)
        
        # Ensure we're using the same motor control method as move_control.py
        # This prevents any advanced.py motor compensation from interfering
        print("Using direct motor control (no advanced.py compensation)")
        
        print("Starting segment execution...")
        success = True
        
        for i, (turn_deg, dist_cm) in enumerate(segments):
            if status_callback:
                status_callback(f"running_segment_{i}")
            
            print(f"\n=== Executing segment {i+1}/{len(segments)} ===")
            print(f"Turn: {turn_deg}°, Move: {dist_cm}cm")
            
            # Execute the command
            segment_success = controller.execute_command(turn_deg, dist_cm)
            
            if not segment_success:
                print(f"❌ Segment {i+1} failed!")
                success = False
                if status_callback:
                    status_callback("error")
                return False
            else:
                print(f"✅ Segment {i+1} completed successfully")
        
        if success:
            print("\n🎉 All path segments completed successfully!")
            if status_callback:
                status_callback("completed")
            return True
        
    except ImportError as e:
        print(f"Import error: {e}")
        print("Make sure move_control.py is in the same directory")
        if status_callback:
            status_callback("error")
        return False
    except Exception as e:
        print(f"Path execution error: {e}")
        if status_callback:
            status_callback("error")
        return False


def draw_text(surface, text, pos, font, color=(240, 240, 240)):
    img = font.render(text, True, color)
    surface.blit(img, pos)


def main():
    global PULSES_PER_CM, PULSES_PER_DEGREE
    pg.init()
    pg.display.set_caption("Telemetry UI")

    script_dir = os.path.dirname(__file__)
    arena_path = os.path.join(script_dir, "arena.png")
    if not os.path.exists(arena_path):
        raise FileNotFoundError("arena.png not found next to telemetry_ui.py")
    arena_img = load_image(arena_path)
    iw, ih = arena_img.get_width(), arena_img.get_height()
    px_per_cm_x, px_per_cm_y = compute_px_cm(iw, ih)

    # Window arrangement: make it resizable
    info = pg.display.Info()
    w, h = int(info.current_w * 0.9), int(info.current_h * 0.9)
    screen = pg.display.set_mode((w, h), pg.RESIZABLE)
    font = pg.font.SysFont(None, 18)
    font_big = pg.font.SysFont(None, 24)

    # Load plan and checkpoints; if absent, auto-build from fruit tags
    segments = load_path(script_dir)
    checkpoints = load_checkpoints(script_dir)
    if not segments or not checkpoints:
        cps, segs = build_auto_path(script_dir)
        if cps and segs:
            checkpoints, segments = cps, segs

    # Load fruits (red/black/green)
    reds, blacks, greens = load_fruits_for_overlay(script_dir)

    # Telemetry init
    init_bot_control(verbose_telemetry=False)

    # Initialize odometry system
    odometry = Odometry()
    if checkpoints:
        # Start odometry at first checkpoint
        odometry.set_position(checkpoints[0][0], checkpoints[0][1], 0.0)

    # Phase tracking
    auto_track = True
    seg_idx = 0
    phase = "idle"  # "turn", "move"
    ROT_TOL = 5.0  # degrees
    DIST_TOL = 3.0  # cm
    move_start_lidar_mm = None
    move_target_cm = 0.0
    seg_heading = None
    
    # Path following state
    path_following = False
    path_thread = None
    execution_status = "stopped"  # "stopped", "running", "paused", "completed", "error"

    # Live pose (in cm); initialize at first checkpoint if available
    live_x_cm = checkpoints[0][0] if checkpoints else 0.0
    live_y_cm = checkpoints[0][1] if checkpoints else 0.0
    live_heading_deg = 0.0  # 0° = up; we use gyro-integrated rotation as heading

    clock = pg.time.Clock()
    running = True
    last_calibration_refresh = 0.0
    while running:
        ww, wh = screen.get_size()
        scale, offset = fit_scale_and_offset((ww, wh), (iw, ih))

        for e in pg.event.get():
            if e.type == pg.QUIT:
                running = False
            elif e.type == pg.KEYDOWN:
                if e.key in (pg.K_ESCAPE, pg.K_q):
                    running = False
                elif e.key == pg.K_r:
                    # Force regenerate: clear files then rebuild
                    try:
                        p1 = os.path.join(script_dir, "path.csv")
                        p2 = os.path.join(script_dir, "checkpoints_cm.csv")
                        if os.path.exists(p1): os.remove(p1)
                        if os.path.exists(p2): os.remove(p2)
                    except Exception:
                        pass
                    cps, segs = build_auto_path(script_dir)
                    segments = segs or []
                    checkpoints = cps or []
                    # Reload fruits too (if user changed tags)
                    reds, blacks, greens = load_fruits_for_overlay(script_dir)
                    seg_idx = 0
                    phase = "idle"
                    move_start_lidar_mm = None
                    # Reset live pose to first checkpoint
                    if checkpoints:
                        live_x_cm, live_y_cm = checkpoints[0]
                        odometry.set_position(checkpoints[0][0], checkpoints[0][1], 0.0)
                    else:
                        live_x_cm, live_y_cm = 0.0, 0.0
                        odometry.reset()
                    live_heading_deg = 0.0
                elif e.key == pg.K_a:
                    auto_track = not auto_track
                elif e.key == pg.K_LEFTBRACKET and not auto_track:
                    seg_idx = max(0, seg_idx - 1)
                    phase = "idle"
                elif e.key == pg.K_RIGHTBRACKET and not auto_track:
                    seg_idx = min(max(0, len(segments) - 1), seg_idx + 1)
                    phase = "idle"
                elif e.key == pg.K_s:
                    # Start/stop path following
                    if not path_following and segments:
                        print("Starting path execution...")
                        execution_status = "starting"
                        path_following = True
                        seg_heading = 0.0
                        
                        def status_update(status):
                            nonlocal execution_status
                            execution_status = status
                            
                        def path_runner():
                            nonlocal path_following, execution_status
                            try:
                                execute_path_segments(segments, status_update)
                            finally:
                                path_following = False
                                if execution_status not in ["completed", "error"]:
                                    execution_status = "stopped"
                        
                        path_thread = threading.Thread(target=path_runner, daemon=True)
                        path_thread.start()
                    elif path_following:
                        print("Stopping path execution...")
                        path_following = False
                        execution_status = "stopped"
                elif e.key == pg.K_o:
                    # Reset odometry to current position or first checkpoint
                    if checkpoints:
                        odometry.set_position(checkpoints[0][0], checkpoints[0][1], 0.0)
                        print(f"Odometry reset to first checkpoint: {checkpoints[0]}")
                    else:
                        odometry.reset()
                        print("Odometry reset to origin")

        # Telemetry snapshot
        now_time = time.time()
        if now_time - last_calibration_refresh >= CALIBRATION_REFRESH_INTERVAL:
            last_calibration_refresh = now_time
            refreshed_ppc = load_pulses_per_cm(DEFAULT_PULSES_PER_CM)
            refreshed_ppd = load_pulses_per_degree()
            if abs(refreshed_ppc - PULSES_PER_CM) > 1e-6:
                PULSES_PER_CM = refreshed_ppc
            if abs(refreshed_ppd - PULSES_PER_DEGREE) > 1e-6:
                PULSES_PER_DEGREE = refreshed_ppd

        imu = get_full_imu_data()
        rotation_deg = get_rotation_degrees()
        lidar_mm = get_current_distance()
        lidar_fresh = is_lidar_data_fresh(max_age_seconds=1.0)
        
        # Update odometry with latest encoder data
        encoders, enc_timestamp = get_latest_encoders()
        left_enc = encoders.get('m1', 0)
        right_enc = encoders.get('m2', 0)
        odometry.update(left_enc, right_enc)
        odometry_x, odometry_y, odometry_heading = odometry.get_pose()
        left_dist, right_dist = odometry.get_total_distance()
        balance_ticks = left_enc - right_enc
        balance_cm = balance_ticks / PULSES_PER_CM if PULSES_PER_CM else 0.0
        cumulative_balance_cm = left_dist - right_dist

        # Update live heading from gyro-derived rotation (wrap to [0,360))
        live_heading_deg = (rotation_deg % 360.0 + 360.0) % 360.0

        # Auto phase estimation
        if auto_track and segments:
            if seg_idx >= len(segments):
                phase = "done"
            else:
                turn_deg, dist_cm = segments[seg_idx]
                if phase in ("idle", "turn"):
                    # Expect the robot to turn towards turn_deg (relative turn)
                    phase = "turn"
                    # Detect completion of turn by rotation within tolerance
                    if abs(rotation_deg - turn_deg) <= ROT_TOL:
                        phase = "move"
                        move_start_lidar_mm = lidar_mm
                        move_target_cm = dist_cm
                        # Compute expected absolute segment heading: previous seg headings accumulate
                        # For visualization, derive from plan: accumulate turns
                        # But for simplicity, compute seg heading relative to up using plan increments
                        # We'll approximate by summing relative turns from start (0° at up)
                        seg_heading = sum(t for (t, _) in segments[:seg_idx+1]) % 360.0
                elif phase == "move":
                    # Estimate traveled using lidar delta in cm
                    if move_start_lidar_mm is not None and lidar_fresh:
                        traveled_cm = (lidar_mm - move_start_lidar_mm) / 10.0
                        # Finish segment when close to target
                        if abs(move_target_cm - traveled_cm) <= DIST_TOL:
                            seg_idx += 1
                            phase = "idle"
                            move_start_lidar_mm = None

        # Draw arena and overlays
        screen.fill((15, 18, 22))
        if abs(scale - 1.0) < 1e-6:
            screen.blit(arena_img, offset)
        else:
            scaled = pg.transform.smoothscale(arena_img, (int(iw * scale), int(ih * scale)))
            screen.blit(scaled, offset)

    # Draw path (from checkpoints)
        # Convert checkpoints (cm) -> image px -> screen
        pts_img = [cm_to_image_xy(x, y, px_per_cm_x, px_per_cm_y) for (x, y) in checkpoints]
        pts_scr = [image_to_screen(p, scale, offset) for p in pts_img]
        # Segments coloring
        for i in range(1, len(pts_scr)):
            a = pts_scr[i - 1]
            b = pts_scr[i]
            if i - 1 < seg_idx:
                color = (100, 200, 100)  # done (green)
            elif i - 1 == seg_idx:
                color = (255, 255, 0)    # current (bright yellow)
            else:
                color = (120, 120, 120)  # pending (gray)
            pg.draw.line(screen, color, a, b, 3)
            pg.draw.circle(screen, color, (int(a[0]), int(a[1])), 4)
        if pts_scr:
            pg.draw.circle(screen, (200, 200, 200), (int(pts_scr[-1][0]), int(pts_scr[-1][1])), 4)

        # Estimated robot pose on current segment (simple progress along segment)
        if segments and checkpoints and 0 <= seg_idx < len(segments) and len(checkpoints) >= 2:
            # Compute progress ratio during move phase
            ratio = 0.0
            if phase == "move" and move_start_lidar_mm is not None and lidar_fresh:
                traveled_cm = (lidar_mm - move_start_lidar_mm) / 10.0
                if abs(move_target_cm) > 1e-3:
                    ratio = max(0.0, min(1.0, traveled_cm / move_target_cm))
            # Current segment endpoints in cm
            i0 = seg_idx
            if i0 + 1 < len(checkpoints):
                p0 = checkpoints[i0]
                p1 = checkpoints[i0 + 1]
                x = p0[0] + (p1[0] - p0[0]) * ratio
                y = p0[1] + (p1[1] - p0[1]) * ratio
                # Persist live pose in cm
                live_x_cm, live_y_cm = x, y
                # Draw robot marker (lidar-based estimate)
                rx_img, ry_img = cm_to_image_xy(x, y, px_per_cm_x, px_per_cm_y)
                rx, ry = image_to_screen((rx_img, ry_img), scale, offset)
                pg.draw.circle(screen, (255, 80, 80), (int(rx), int(ry)), 6)
                # Draw orientation arrow (use accumulated planned heading if available)
                heading = seg_heading if seg_heading is not None else live_heading_deg
                rad = math.radians(heading)
                # 0° up => vector (0, -1); we map to screen delta using img px/cm relationship roughly
                vx = math.sin(rad) * 20
                vy = -math.cos(rad) * 20
                pg.draw.line(screen, (255, 80, 80), (rx, ry), (rx + vx, ry + vy), 3)
        else:
            # If we can't compute from segments, still draw live pose at last known location
            rx_img, ry_img = cm_to_image_xy(live_x_cm, live_y_cm, px_per_cm_x, px_per_cm_y)
            rx, ry = image_to_screen((rx_img, ry_img), scale, offset)
            pg.draw.circle(screen, (255, 80, 80), (int(rx), int(ry)), 6)
            rad = math.radians(live_heading_deg)
            vx = math.sin(rad) * 20
            vy = -math.cos(rad) * 20
            pg.draw.line(screen, (255, 80, 80), (rx, ry), (rx + vx, ry + vy), 3)
        
        # Draw odometry-based robot position (encoder-based estimate)
        odo_rx_img, odo_ry_img = cm_to_image_xy(odometry_x, odometry_y, px_per_cm_x, px_per_cm_y)
        odo_rx, odo_ry = image_to_screen((odo_rx_img, odo_ry_img), scale, offset)
        
        # Check if robot position is valid (within arena bounds)
        if 0 <= odo_rx <= ww and 0 <= odo_ry <= wh:
            # Make robot position more visible
            pg.draw.circle(screen, (0, 255, 0), (int(odo_rx), int(odo_ry)), 12)  # Larger green circle
            pg.draw.circle(screen, (0, 0, 0), (int(odo_rx), int(odo_ry)), 12, 3)  # Black border
            pg.draw.circle(screen, (255, 255, 255), (int(odo_rx), int(odo_ry)), 6)  # White center
            
            # Draw odometry orientation arrow (thicker and more visible)
            odo_rad = math.radians(odometry_heading)
            odo_vx = math.sin(odo_rad) * 30
            odo_vy = -math.cos(odo_rad) * 30
            pg.draw.line(screen, (0, 0, 0), (odo_rx, odo_ry), (odo_rx + odo_vx, odo_ry + odo_vy), 6)
            pg.draw.line(screen, (255, 255, 255), (odo_rx, odo_ry), (odo_rx + odo_vx, odo_ry + odo_vy), 4)
        else:
            # Fallback: show robot at first checkpoint if odometry is invalid
            if checkpoints:
                fallback_x, fallback_y = checkpoints[0]
                fallback_rx_img, fallback_ry_img = cm_to_image_xy(fallback_x, fallback_y, px_per_cm_x, px_per_cm_y)
                fallback_rx, fallback_ry = image_to_screen((fallback_rx_img, fallback_ry_img), scale, offset)
                
                # Draw fallback robot position (red to indicate fallback)
                pg.draw.circle(screen, (255, 0, 0), (int(fallback_rx), int(fallback_ry)), 12)
                pg.draw.circle(screen, (0, 0, 0), (int(fallback_rx), int(fallback_ry)), 12, 3)
                pg.draw.circle(screen, (255, 255, 255), (int(fallback_rx), int(fallback_ry)), 6)
                
                # Draw "?" to indicate fallback position
                font_small = pg.font.SysFont(None, 16)
                text = font_small.render("?", True, (0, 0, 0))
                text_rect = text.get_rect(center=(int(fallback_rx), int(fallback_ry)))
                screen.blit(text, text_rect)

        # Draw fruits overlay
        sq_w = FRUIT_SIZE_CM * px_per_cm_x * scale
        sq_h = FRUIT_SIZE_CM * px_per_cm_y * scale
        def draw_fruits(points, color):
            for (x_cm, y_cm) in points:
                ix, iy = cm_to_image_xy(x_cm, y_cm, px_per_cm_x, px_per_cm_y)
                sx, sy = image_to_screen((ix, iy), scale, offset)
                rect = pg.Rect(0, 0, sq_w, sq_h)
                rect.center = (sx, sy)
                pg.draw.rect(screen, color, rect)
                pg.draw.rect(screen, (220, 220, 220), rect, 1)
        # Order: green underlay, then red/black on top
        draw_fruits(greens, (60, 180, 60))   # green default
        draw_fruits(blacks, (30, 30, 30))    # black
        draw_fruits(reds, (220, 60, 60))     # red

        # Right side HUD panel (transparent overlay)
        hud = pg.Surface((int(ww * 0.34), wh), pg.SRCALPHA)
        hud.fill((0, 0, 0, 140))
        screen.blit(hud, (ww - hud.get_width(), 0))
        hud_x = ww - hud.get_width() + 12
        y = 10
        draw_text(screen, "Telemetry UI", (hud_x, y), font_big)
        y += 28
        draw_text(screen, f"Segments: {len(segments)}  Index: {seg_idx}  Phase: {phase}", (hud_x, y), font)
        y += 22
        
        # Path execution status
        status_color = (240, 240, 240)
        if execution_status == "running" or execution_status.startswith("running_segment"):
            status_color = (100, 255, 100)
        elif execution_status == "error":
            status_color = (255, 100, 100)
        elif execution_status == "completed":
            status_color = (100, 255, 255)
        
        status_text = execution_status.replace("running_segment_", "Running seg ")
        draw_text(screen, f"Path Status: {status_text}", (hud_x, y), font, status_color)
        y += 22
        draw_text(screen, f"Calib: PPD={PULSES_PER_DEGREE:.3f}  PPCM={PULSES_PER_CM:.3f}", (hud_x, y), font)
        y += 18
        # IMU
        draw_text(screen, "IMU:", (hud_x, y), font_big)
        y += 22
        accel = imu.get('accel', {})
        gyro = imu.get('gyro', {})
        heading = imu.get('heading', 0.0)
        temp_c = imu.get('temp_c', 0.0)
        draw_text(screen, f"Accel: x={accel.get('x',0):.2f} y={accel.get('y',0):.2f} z={accel.get('z',0):.2f}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Gyro:  x={gyro.get('x',0):.2f} y={gyro.get('y',0):.2f} z={gyro.get('z',0):.2f}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Heading(abs): {heading:.1f}°  Rot(rel): {rotation_deg:.1f}°", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Temp: {temp_c:.1f}°C", (hud_x, y), font)
        y += 24

        # Lidar
        draw_text(screen, "LIDAR:", (hud_x, y), font_big)
        y += 22
        st = "OK" if lidar_fresh else "STALE"
        draw_text(screen, f"Distance: {lidar_mm} mm  [{st}]", (hud_x, y), font)
        y += 24

        # Live Pose
        draw_text(screen, "Pose:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, f"x={live_x_cm:.1f} cm  y={live_y_cm:.1f} cm  heading={live_heading_deg:.1f}°", (hud_x, y), font)
        y += 24

        # Encoders
        draw_text(screen, "Encoders:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, f"Left (m1): {left_enc}  Right (m2): {right_enc}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"m3: {encoders.get('m3', 0)}  m4: {encoders.get('m4', 0)}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Δ ticks(L-R): {balance_ticks:+d}  Δ cm: {balance_cm:+.2f}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Cumulative drift: {cumulative_balance_cm:+.2f} cm", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Timestamp: {enc_timestamp}", (hud_x, y), font)
        y += 24
        
        # Odometry
        draw_text(screen, "Odometry:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, f"Position: x={odometry_x:.1f} y={odometry_y:.1f} cm", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Heading: {odometry_heading:.1f}°", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Wheel distances: L={left_dist:.1f} R={right_dist:.1f} cm", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Screen pos: ({int(odo_rx)}, {int(odo_ry)})", (hud_x, y), font)
        y += 24

        # Controls
        draw_text(screen, "Controls:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, "R: reload plan   A: auto track on/off   [/]: manual seg", (hud_x, y), font)
        y += 18
        draw_text(screen, "S: start/stop path execution", (hud_x, y), font)
        y += 18
        draw_text(screen, "O: reset odometry", (hud_x, y), font)
        y += 18
        draw_text(screen, "Esc/Q: quit", (hud_x, y), font)

        # Robot Legend
        y += 14
        draw_text(screen, "Robot Indicators:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, "Red circle: Lidar-based estimate", (hud_x, y), font, (255, 80, 80))
        y += 18
        draw_text(screen, "Green circle: Encoder odometry", (hud_x, y), font, (80, 255, 80))
        y += 18

        # Fruit Legend
        draw_text(screen, "Fruits:", (hud_x, y), font_big)
        y += 22
        draw_text(screen, f"Red targets: {len(reds)}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Black obstacles: {len(blacks)}", (hud_x, y), font)
        y += 18
        draw_text(screen, f"Green (defaults): {len(greens)}", (hud_x, y), font)

        pg.display.flip()
        clock.tick(60)

    cleanup()
    pg.quit()


if __name__ == "__main__":
    main()
