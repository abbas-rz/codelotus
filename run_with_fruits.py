#!/usr/bin/env python3
"""
Run robot path with fruit color mapping
- Loads fruit_config.json from fruit_ui.py
- Loads path.csv/checkpoints generated by path_planner.py
- Executes robot path based on mapping
"""

import os
import sys
import time
import csv
import json

try:
    from move_control import RobotController
    import advanced
    from path_planner import build_auto_path
except ImportError as e:
    print(f"ERROR: Required modules not found: {e}")
    sys.exit(1)


class FruitTrackRunner:
    def __init__(self, script_dir=None, config_file="fruit_config.json"):
        self.script_dir = script_dir or os.path.dirname(__file__)
        self.config_file = os.path.join(self.script_dir, config_file)
        self.path_segments = []
        self.checkpoints = []
        self.fruit_config = {}
        self.robot = RobotController()

    def load_config(self):
        """Load fruit color mapping"""
        if not os.path.exists(self.config_file):
            print(f"ERROR: Config file {self.config_file} not found. Run fruit_ui.py first.")
            sys.exit(1)

        with open(self.config_file, "r") as f:
            self.fruit_config = json.load(f)

        print("Loaded fruit config:", self.fruit_config)

    def _plan_files(self):
        return (
            os.path.join(self.script_dir, "path.csv"),
            os.path.join(self.script_dir, "checkpoints_cm.csv"),
        )

    def _read_path_csv(self, path_csv):
        segments = []
        try:
            with open(path_csv, "r", newline="") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    turn = float(row.get("turn_deg", 0.0))
                    distance = float(row.get("distance_cm", 0.0))
                    segments.append((turn, distance))
        except FileNotFoundError:
            return []
        return segments

    def _read_checkpoints_csv(self, checkpoints_csv):
        checkpoints = []
        try:
            with open(checkpoints_csv, "r", newline="") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    x = float(row.get("x_cm", 0.0))
                    y = float(row.get("y_cm", 0.0))
                    checkpoints.append((x, y))
        except FileNotFoundError:
            return []
        return checkpoints

    def load_path(self):
        path_csv, checkpoints_csv = self._plan_files()
        segments = self._read_path_csv(path_csv)
        checkpoints = self._read_checkpoints_csv(checkpoints_csv)

        if not segments or not checkpoints:
            print("Path files missing or empty – regenerating via path_planner.build_auto_path().")
            checkpoints, segments = build_auto_path(self.script_dir)

        if not segments:
            print("ERROR: No path segments available. Ensure fruit_ui/path_planner data is configured.")
            sys.exit(1)

        self.path_segments = segments
        self.checkpoints = checkpoints
        print(f"Loaded {len(self.path_segments)} path segments from path.csv")

    def execute(self):
        """Execute the generated path based on fruit mapping"""
        if not self.path_segments:
            print("No path data found!")
            return

        if not self.fruit_config:
            print("No fruit config found!")
            return

        print("\n=== Starting Fruit-Based Track Execution ===")
        print(f"Path segments: {len(self.path_segments)}")
        print(f"Fruit mapping: {self.fruit_config}")

        # Example rule: Different color → different speed
        color_speed_map = {
            "Red": 40,
            "Green": 60,
            "Blue": 80,
            "Yellow": 100,
        }

        time.sleep(2)
        success_count = 0

        for i, (angle, measure) in enumerate(self.path_segments):
            fruit_key = f"Fruit{i+1}"
            chosen_color = self.fruit_config.get(fruit_key, "Green")  # default Green
            speed = color_speed_map.get(chosen_color, 60)

            print(f"\n--- Segment {i+1} ---")
            print(f"Target: {angle:.1f}° turn, {measure:.1f} cm forward")
            print(f"Fruit: {fruit_key} → {chosen_color}, Speed: {speed}")

            # Adjust robot speed before execution
            self.robot.configure_speeds(move_speed=speed)

            if not self.robot.execute_command(angle, measure):
                print(f"⚠️ Failed to execute segment {i+1}")
                break

            success_count += 1
            print(f"✅ Segment {i+1} done with {chosen_color}")

        print(f"\n=== Execution finished: {success_count}/{len(self.path_segments)} segments successful ===")


def main():
    print("=== Fruit-Based Robot Runner ===")

    if not advanced.init_bot_control(verbose_telemetry=False):
        print("ERROR: Failed to initialize robot control")
        return

    runner = FruitTrackRunner()
    runner.load_config()
    runner.load_path()
    runner.execute()

    advanced.cleanup()
    print("Robot control cleaned up.")


if __name__ == "__main__":
    main()
